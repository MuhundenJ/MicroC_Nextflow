---
title: "MicroC_Test"
author: "Muhunden Jayakrishnan"
date: "12/2/2024"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

## Install GENOVA -- Note that installation works only from local RProjects (.ie. not on mounted network drives!)
library("remotes")
#remotes::install_github("robinweide/GENOVA")
library("GENOVA")
library("tibble")
library("tidyverse")
## Install OHCA 
# 
# BiocManager::install("HiCExperiment", ask = FALSE)
# BiocManager::install("HiCool", ask = FALSE)
# BiocManager::install("HiContacts", ask = FALSE)
# BiocManager::install("HiContactsData", ask = FALSE)
# BiocManager::install("fourDNData", ask = FALSE)
# BiocManager::install("DNAZooData", ask = FALSE)

#BiocManager::install("GenomicRanges")


library("GenomicRanges")
library("HiCExperiment")
library("HiCool")
library("HiContacts")
library("HiContactsData")
library("fourDNData")
library("DNAZooData")
library("InteractionSet")

# install.packages("cowplot")

# BiocManager::install("WGCNA",force=TRUE)
# BiocManager::install("terra")
# 
# BiocManager::install("BSgenome.Hsapiens.UCSC.hg38")
# BiocManager::install("BSgenome.Dmelanogaster.UCSC.dm6")
```
##Intro 

We will test functions from OCHA and GENOVA for analysis of MicroC data.

OHCA uses GInteractions data structure which is an extension of GRanges 

GInteractions objects have interacting anchors stored in them. Each anchor can be accessed and modified as necessary (or attach metadata to each anchor separately).

FindOverlaps methods work with GInteractions objects. GI Objects can be overlapped with GRanges or GI objects etc. See ?`Interaction-overlaps`

Load .mcool datasets

CoolFile function ONLY establishes connection to locally stored file - ITS NOT LOADED INTO MEMORY 

HiCExperiment objects are generated when CoolFiles are loaded into memory in GInteraction format 

NOTE - HiCExperiment objects can be merged -- Is it fine merging individually balanced experiments?

UPDATE - HiCExperiment has issues correctly reading .mcools processed by hictk (balance scores not retreived properly, seqnames errors) -> Reprocessed files with cooler and cooltools 
Further, chrM throws issues -> So remove using cooltools rearrange

```{r LoadCool}
cf <- CoolFile("GSM5224835_WT2_rearrange.mcool")

availableResolutions(cf)
availableChromosomes(cf)

# Run import with default parameters only for smaller files ! -> Otherwise consider using 'focus'
cf_hic <- import(cf)

saveRDS(cf_hic,file="cf_hic.rds")

#cf_int <- interactions(cf_hic)
#anchors(cf_int)

### Example of how to subset - this example is for the BACmids data
#cf_int[cf_int %over% GRanges(data.frame(chrom="MG_1::chr2R:9783303-9864769",start=5000, end=7500))]

```
Default loading of data is the whole genome ! - Can be memory intensive. This can be adjusted by using the focus parameter in import !

Note : Focus cannot take chromosome names containing special characters ! -> Wont work for our BACs

Other operations that are possible on mcool files

```{r LoadCool_params, echo=FALSE}

interactions(cf_hic)

bins(cf_hic)

scores(cf_hic,"balanced")

topologicalFeatures(cf_hic,"compartments"). ### can add Topological features 

```
```{r}
## Several ways to subset -> Square brackets is recommended 

#cf_hic_eve <- subsetByOverlaps(cf_hic, ranges=GRanges("chr2R:9927180-10031530"))

cf_hic_eve <- cf_hic["chr2R:9927180-10031530"]

as.matrix(cf_hic_eve,sparse=FALSE)[1:5,1:5]

```
Note that you can merge .mcool files here, but recommended to merge and then ICE with cooler

## Explore plotting features

Interactions matrix can be generated by coercing HiCExperiment objects -- Note that main diagonal elements (self interaction) bins are very low, likely removed during filtering of self-ligated products - near diagonal bins have higher counts - which makes sense as nearby bins interact more frequenzly !

Plot of raw counts - Note that plotMatrix defaults to balance scores 

```{r}
plotMatrix(cf_hic_eve,use.scores='count')
```

Horizontal Heatmaps

-- can add loops, borders etc. as parameters 

```{r}

plotMatrix(cf_hic_eve,maxDistance=10031530-9927180,limits=c(-3,-2.25))

```
Plotting in different resolutions (100bp vs 400bp)

```{r}
cowplot::plot_grid(plotMatrix(cf_hic_eve, use.scores= 'balanced', scale='log10',limits=c(-3,-2)),
                   plotMatrix(zoom(cf_hic_eve,resolution=400),use.scores= 'balanced', scale='log10',limits=c(-3,-1)), 
                   nrow=1)
```

## Data transformation 

Counts can be converted in following ways -

a) Convert counts plot into Observed/Expected ratios (Expected based on polymer behaviour)
b) Convert into autocorrelation plot - Broad segregation into compartments
c) Despeckled dentrended - Detrended map, but this time over coarse-grained bins 

```{r}

cf_hic_eve_detrended <- detrend(cf_hic_eve,use.scores = "count")

cf_hic_eve_autocorr <- autocorrelate(cf_hic_eve,use.scores = "count")

cf_hic_eve_despeckled <- despeckle(cf_hic_eve_detrended,use.scores = 'detrended',focal.size=2)


```
Plot counts vs detrended (O/E)

```{r}
cowplot::plot_grid(plotMatrix(cf_hic_eve_detrended, use.scores= 'count', scale='log10',limits=c(0,1)),
                   plotMatrix(cf_hic_eve_detrended, use.scores= 'detrended',scale='linear', limits=c(-1,1),cmap=bwrColors()), 
                   nrow=1)
```
Plot counts vs autocorr

```{r}
cowplot::plot_grid(plotMatrix(cf_hic_eve_detrended, use.scores= 'count', scale='log10',limits=c(0,1)),
                   plotMatrix(cf_hic_eve_autocorr,use.scores='autocorrelated',scale='linear', limits = c(-0.4,0.4),cmap=bgrColors()),
                   nrow=1)

```
Plot counts vs despeckled

```{r}
cowplot::plot_grid(plotMatrix(cf_hic_eve_detrended, use.scores= 'count', scale='log10',limits=c(0,1)),
                   plotMatrix(cf_hic_eve_despeckled,use.scores='detrended.despeckled',scale='linear', limits = c(-1,1),cmap=bgrColors()),
                   nrow=1)
```

Possibly despeckled matrices can be used to call loops ? - TODO : Test

Test ICE balancing with OHCA - Works pretty well !

```{r}
cf_hic_eve_balanced <- normalize(cf_hic_eve)

cowplot::plot_grid(plotMatrix(cf_hic_eve_detrended, use.scores= 'count',limits=c(0,1)),
                   plotMatrix(cf_hic_eve_balanced,use.scores='ICE',limits=c(-3,-1)),
                   nrow=1)

```


# Virtual 4C profiles
```{r}
v4c <- virtual4C(cf_hic_eve,use.scores = 'count', viewpoint = GRanges("chr2R:9972500-9973500"))

df <- as_tibble(v4c)
ggplot(df, aes(x = center, y = score)) + 
    geom_area(position = "identity", alpha = 0.5) + 
    theme_bw() + 
    labs(x = "Position", y = "Contacts with viewpoint") +
    scale_x_continuous(labels = scales::unit_format(unit = "M", scale = 1e-06))
```
## Find topological features 

Its possible to call insulation scores + TADs, loops, compartments with OHCA with parallel cores 

Note: We don't need compartments -> For if needed to generate, then need a phasing track to select PC1 and to label A compartment -> Default is usage of GC content/density - Not very useful in Drosophila, so also try ePol ChIP data/gene body density -> Can be generated by cooltools?

Visualize some test regions

```{r}

#phasing_track_gc <- BSgenome.Dmelanogaster.UCSC.dm6::BSgenome.Dmelanogaster.UCSC.dm6
#cf_hic_eve_compt <- getCompartments(cf_hic_eve_balanced,genome=phasing_track_gc)

#borders and loops for Batut et al
borders_Batut <- import("metadata/GSE171396_Batut_MicroC_yw_CC14_Boundaries_min1.25.bed")
loops_Batut <- import("metadata/GSE171396_Batut_MicroC_yw_CC14_SIP_Loops_Filtered_clean.bedpe") %>% makeGInteractionsFromGRangesPairs()

#loops called by SIP 
loops_new <- import("metadata/finalLoops2024-12-05T115841_029821503_clean.bedpe") %>% makeGInteractionsFromGRangesPairs()

#loops called by Mustache 
#loops <- import("../../../mustache/loops_1kb_pt0.01_sz3.bedpe") %>% makeGInteractionsFromGRangesPairs()


region_2 <- cf_hic["chr3L:12400000-12750000"]
# region_3 <- cf_hic["chr3L:13100000-13300000"]
# region_4 <- cf_hic["chr3L:14500000-14700000"]
# region_5 <- cf_hic["chr3L:20600000-20750000"]
# region_6 <- cf_hic["chr3L:21150000-21250000"]
# region_7 <- cf_hic["chr3R:6750000-7060000"]
# region_8 <- cf_hic["chr2L:14400000-14600000"]
# region_9 <- cf_hic["chr2L:17550000-17900000"] ## this is a volcano like TAD - large scale checkerboard
# region_10 <- cf_hic["chr2L:21800000-22100000"]
# region_11<- cf_hic["chr2R:11700000-11850000"]
# region_12 <- cf_hic["chr2R:12000000-12400000"] ## volcano like TAD ? - large scale checkerboard
# region_13 <- cf_hic["chr3L:600000-800000"]
# region_14 <- cf_hic["chr3L:8975000-9075000"] ## beautfiul loops
# region_15 <- cf_hic["chr3L:11200000-11600000"]## beautfiul loops
# region_16 <- cf_hic["chr3R:16710000-16750000" ]## good looking volcano ! -- THIS IS THE BX-C locus !

plotMatrix(zoom(cf_hic_eve,resolution=400),use.scores='balanced',loops=loops_new,borders=borders_Batut,limits=c(-3,-1))
plotMatrix(zoom(region_2,resolution=800),use.scores='balanced',borders=borders_Batut,loops=loops_new,limits=c(-3,-1))
                

```

Our new loop calls are pretty good, but there are some noisy pixels which can lead to False Positives - Add additional filtering critieria based on scores and marginals ! - TO DO 

Visualize as Aggregate Plots : NEED TO PROVIDE WHOLE GENOME CONTACTS -> Use newly calculated loops 

OHCA generates one object containing all the matrices for the targets. Further it calculates detrended scores and is used for visualization ! - Possibly detrended scores are more sensitive for also capturing volcano plumes? 

```{r}

cf_hic <- zoom(cf_hic,resolution = 800)

loops_new$index <- 1:length(loops_new)  ## need to add index as metadata as subsetting AggHiC objects are tricky !

aggr_loops <- aggregate(cf_hic,targets=loops_new,flankingBins=5)

dim(slices(aggr_loops, 'count'))

plotMatrix(
    aggr_loops, 
    use.scores = 'detrended', 
    scale = 'linear', 
    limits = c(-1, 1), 
    cmap = bgrColors()
)

```
Visualize matrix for just eve loop

Coordinates of eve-loop anchors are "chr2R:9973000-9973500" and "chr2R:9988500-9989000". However, we cant directly use this to get the corresponding matrix as these coordinates are transformed to 'targets' which are 8kb (10 bins x 800 bp) around the loop centers. For now, just extract based on row# 

```{r}

targets_info <- data.frame(topologicalFeatures(aggr_loops,'targets')) ### 366 entry is the eve loop - based on manual examination (113,161 is another)

eve_matrix <- slices(aggr_loops,'balanced')[1:11,1:11,113]
ctrlloop_matrix <- slices(aggr_loops,'balanced')[1:11,1:11,40]

heatmap(eve_matrix[c(11:1),,drop=FALSE],Rowv=NA,Colv = NA,main="eve loop") ## reverse rows so (1,1) is top left
heatmap(ctrlloop_matrix[c(11:1),,drop=FALSE],Rowv=NA,Colv = NA,scale="none",main="standard loop")



```
```{r}

generate_strict_contained_masks <- function(size) {
  # Initialize empty matrices
  top_right <- matrix(0, nrow = size, ncol = size)

  i <- 1

  while (i <= ceiling(size/2)){
    j <- size
    while(j > floor(size/2)){
    top_right[i,j] <- 1
    j = j-1
    }
    i = i+1
  }
  
  return(top_right)
}


generate_strict_contained_masks(11)

```
```{r}

filter_matrix_strict_contained <- function(matrix,threshold_na,threshold_zero) {
  size <- nrow(matrix)
  mask_topRight <- generate_strict_contained_masks(size)
  mask_bottomLeft <- t(mask_topRight)
  mask_topLeft_bottomRight <- mask_topRight + mask_bottomLeft

  # Treat NAs and 0s 
  if (((sum(is.na(matrix))/length(matrix)) > threshold_na) | ((sum(matrix==0,na.rm=TRUE))/length(matrix)) > threshold_zero){
    
    return (FALSE)
    
  } else {
    
  # Extract signals
  matrix[is.nan(matrix)] <- quantile(matrix,probs=0.1,na.rm=TRUE)[[1]]
    
  total_signal <- sum(matrix)
  positive_signal <- sum(matrix[mask_topLeft_bottomRight != 0])
  negative_signal <- sum(matrix[mask_topLeft_bottomRight == 0])
  
  mask_topRight[ceiling(size/2),ceiling(size/2)] <- 1
  mask_bottomLeft[ceiling(size/2),ceiling(size/2)] <- 1
  
  top_right_signal <- sum(matrix[mask_topRight == 1])
  bottom_left_signal <- sum(matrix[mask_bottomLeft == 1])
  
  # Compute ratios
  positive_ratio <- positive_signal / total_signal
  top_right_ratio <- top_right_signal / positive_signal
  bottom_left_ratio <- bottom_left_signal / positive_signal
  
  # Check criteria
  passes_positive <- positive_ratio >= 0.75
  passes_balance <- top_right_ratio >= 0.3 && bottom_left_ratio >= 0.3
  
  return(passes_positive && passes_balance)
    
  }
  
}

filter_matrix_strict_contained(ctrlloop_matrix,0.05,0.1)
filter_matrix_strict_contained(eve_matrix,0.05,0.1)
```
```{r}

loops_new$is_volcano <- FALSE

for (i in 1:length(loops_new)){
  test_matrix <- slices(aggr_loops,'balanced')[1:11,1:11,i]
  
  loops_new$is_volcano[i] <- filter_matrix_strict_contained(test_matrix,0.05,0.1)
  
}

loops_new$is_volcano %>% table()
```

Apparently 13 TRUE volcanoes detected
```{r}

volcano_loops <- loops_new[loops_new$is_volcano==TRUE]
volcano_loops
```

```{r}

cf_hic <- zoom(cf_hic,resolution = 200)

pdf(file="Volcano.pdf",height=5,width=5)
## plot low res maps 
for (i in 1:length(volcano_loops)){
  
  heatmap(slices(aggr_loops,'balanced')[1:11,1:11,volcano_loops[i]$index][c(11:1),,drop=FALSE],Rowv=NA,Colv = NA,main=paste0("LowRes:",volcano_loops[i]$index)) 

}

dev.off()

```


Not very satisfied by the boundaries called by Batut et al. Try new boundary calls at multiple resolutions (with cooltools as well as OHCA inbuilt)

```{r}
bpparam <- SerialParam(progressbar = FALSE)

cf_hic_eve_balanced <- zoom(cf_hic_eve,200) %>%
    getDiamondInsulation(window_size = 50000) %>% 
    getBorders()


HiCExperiment(fileName(cf_hic_eve_balanced), resolution=500,focus="chr2R:9927180-10031530")

plotMatrix(cf_hic_eve_balanced,use.scores='ICE',borders=topologicalFeatures(lol,"borders"),limits=c(-3,-1))



```
```{r}



```


## Possible things to do 

Distance decay curves (not so useful for me)
Differential interaction (DI) analysis with MultiHiCCompare (see OHCA) -> Requires replicates ! 
Trans interaction analysis -> This might be useful if we want to compare interactions across BACs ! 

